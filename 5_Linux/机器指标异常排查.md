- [背景](#背景)
- [CPU使用率分析和异常排查](#cpu使用率分析和异常排查)
  - [什么是CPU使用率](#什么是cpu使用率)
  - [查看CPU使用率(top命令)](#查看cpu使用率top命令)
  - [CPU突然飙升的常见原因](#cpu突然飙升的常见原因)
    - [宿主机cpu超卖(云服务)](#宿主机cpu超卖云服务)
    - [内存问题，导致大量Full GC](#内存问题导致大量full-gc)
    - [代码存在死循环](#代码存在死循环)
- [系统负载（Load）分析和异常排查](#系统负载load分析和异常排查)
  - [什么是系统负载](#什么是系统负载)
  - [CPU使用率与负载（Load）的区别](#cpu使用率与负载load的区别)
  - [查看系统负载](#查看系统负载)
  - [机器正常负载范围（单核）](#机器正常负载范围单核)
  - [负载比较高怎么办？](#负载比较高怎么办)
  - [常见场景](#常见场景)
    - [磁盘读写请求过多就会导致大量I/O等待](#磁盘读写请求过多就会导致大量io等待)
    - [MySQL中存在没有索引的语句或存在死锁.](#mysql中存在没有索引的语句或存在死锁)
    - [外接硬盘故障，常见有挂载了NFS，但是NFS Server故障.](#外接硬盘故障常见有挂载了nfs但是nfs-server故障)
- [内存使用率异常](#内存使用率异常)
  - [内存概念](#内存概念)
    - [物理内存](#物理内存)
    - [虚拟内存](#虚拟内存)
    - [Swap分区](#swap分区)
    - [buffers和cache的区别](#buffers和cache的区别)
  - [查看内存使用情况](#查看内存使用情况)
  - [内存占用飙高怎么办?](#内存占用飙高怎么办)
    - [内存溢出](#内存溢出)
      - [堆内存溢出（outOfMemoryError：java heap space）](#堆内存溢出outofmemoryerrorjava-heap-space)
      - [方法区内存溢出（outOfMemoryError：permgem space）](#方法区内存溢出outofmemoryerrorpermgem-space)
      - [线程栈溢出（java.lang.StackOverflowError）](#线程栈溢出javalangstackoverflowerror)
    - [内存泄露](#内存泄露)
    - [堆外内存使用不当](#堆外内存使用不当)

# 背景
日常的工作中，在衡量服务器的性能时，经常会涉及到几个系统指标，load、cpu、mem、qps、rt等。每个指标都有其独特的意义，很多时候在线上出现问题时，往往会伴随着某些指标的异常。大部分情况下，在问题发生之前，某些指标就会提前有异常显示。

# CPU使用率分析和异常排查

## 什么是CPU使用率
什么是CPU时间片？我们现在所使用的Windows、Linux、Mac OS X都是“多任务操作系统”，就是说他们可以“同时”运行多个程序，比如一边打开Chrome浏览器浏览网页还能一边聊钉钉。但是，实际上一个CPU内核在同一时刻只能干一件事，那操作系统是如何实现“多任务”的呢？大概的方法是让多个进程轮流使用CPU一小段时间。由于这个“一小段时间”很短(在linux上为5ms-800ms之间)，用户感觉不到，就好像是几个程序同时在运行了。上面提到的“一小段时间”就是我们所说的CPU时间片。 现代分时多任务操作系统对CPU都是分时间片使用的。

CPU使用率，就是程序对CPU时间片的占用情况，即CPU使用率 = CPU时间片被程序使用的时间 / 总时间。比如A进程占用10ms，然后B进程占用30ms，然后空闲60ms，再又是A进程占10ms，B进程占30ms，空闲60ms，如果在一段时间内都是如此，那么这段时间内的CPU占用率为40%。

大多数操作系统的CPU占用率分为用户态CPU使用率和系统态CPU使用率。用户态CPU使用率是指执行应用程序代码的时间占总CPU时间的百分比。相比而言，系统态CPU使用率是指应用执行操作系统调用的时间占总CPU时间的百分比。系统态的CPU使用率高意味着共享资源有竞争或者I/O设备之间有大量的交互。

## 查看CPU使用率(top命令)
![avatar](/resource/%E6%9C%BA%E5%99%A8%E6%8C%87%E6%A0%87%E5%BC%82%E5%B8%B8%E6%8E%92%E6%9F%A51.png)

第一行是系统的运行时间和平均负载，可以看到load值确实较高。

第二行是进程的状态，running状态的进程只有1个，这个与上面的load值有些出入。

第三行表示CPU时间都用在了哪里，侧重关注us，id，wa等几个指标。

具体字段的含义: 
* us: 用户空间占用CPU百分比
* sy: 内核空间占用CPU百分比
* ni: 用户进程空间内改变过优先级的进程占用CPU百分比
* id: 空闲CPU百分比
* wa: 等待输入输出的CPU时间百分比
* hi: 硬件中断
* si: 软件中断
* st: 物理机上其他虚拟机占用CPU的时间百分比


## CPU突然飙升的常见原因

### 宿主机cpu超卖(云服务)
查看top结果信息中的cpu st的值，即宿主机cpu时间片分配给宿主机上其他虚拟机时间占比。如果st使用率较大，则cpu占用飙升是由于宿主机超卖导致，联系PE解决.

### 内存问题，导致大量Full GC
*查看Full GC和Young GC次数，如果发现的确存在频繁的Full GC，Dump应用的堆内存，对堆内存进行分析，定位异常代码.

### 代码存在死循环
需要先定位到占用大量cpu时间片的java线程，然后排查对应线程的代码定位原因.

Step1. 直接使用top命令找到CPU占用最高的`进程`（PID为`进程ID`），看一下是否为java`进程`.

Step2. 监控具体的进程下的`线程`. 其中的PID为`线程ID`.

```Sh
# -p指定具体进程, -H线程模式,列出进程下的线程.
top -p [step1查到的进程id] -H
```

Step3. 获得java线程id的十六进制值，通过jstack定位线程堆栈，找到异常类.

```Sh
# 获得java线程id的十六进制值
printf "%x" [线程id]

# 通过jstack定位线程堆栈
sudo -u admin /opt/taobao/java/bin/jstack [进程id] | grep [线程id的16进制]
```

注意：
* jstack的对象是java`进程`的PID，而不是java`线程`的PID.
* 需要切换到admin用户运行命令，否则可能会出现连不上VM的问题.
* 不要使用jstack -F命令，可能会导致应用的所有线程挂起.


# 系统负载（Load）分析和异常排查

## 什么是系统负载
系统负载（Load）是指在一段时间内CPU正在处理以及等待CPU处理的`进程数`之和的统计信息，也就是 CPU使用队列的长度的统计信息。
 
当CPU完全空闲的时候，平均负荷为0；当CPU工作量饱和的时候，平均负荷为1。超过1说明有等待的进程.
 
如果CPU每分钟最多处理100个进程，那么系统负荷0.2，意味着CPU在这1分钟里只处理20个进程；系统负荷1.0，意味着CPU在这1分钟里正好处理100个进程；系统负荷1.7，意味着除了CPU正在处理的100个进程以外，还有70个进程正排队等着CPU处理。

`多核或者单核多处理器`, 比如2个CPU，意味着电脑的处理能力翻了一倍，能够同时处理的进程数量也翻了一倍。
 
所以，2个CPU表明系统负荷可以达到2.0，此时每个CPU都达到100%的工作量。推广开来，n个CPU的电脑，可接受的系统负荷最大为n * 1.0.

举个例子:

把CPU想象成一座大桥，桥上只有一根车道（一个CPU），所有车辆都必须从这根车道上单向通行。

系统负荷为0，意味着大桥上一辆车也没有。

系统负荷为0.5，意味着大桥一半的路段有车。

系统负荷为1.0，意味着大桥的所有路段都有车，也就是说大桥已经"满"了。但是必须注意的是，直到此时大桥还是能顺畅通行的。

系统负荷为1.7，意味着车辆太多了，大桥已经被占满了（100%），后面等着上桥的车辆为桥面车辆的70%。

以此类推，系统负荷2.0，意味着等待上桥的车辆与桥面的车辆一样多；系统负荷3.0，意味着等待上桥的车辆是桥面车辆的2倍。总之，当系统负荷大于1，后面的车辆就必须等待了；系统负荷越大，过桥就必须等得越久。

CPU的系统负荷，基本上等同于上面的类比。大桥的通行能力，就是CPU的最大工作量；桥梁上的车辆，就是一个个等待CPU处理的进程（process）。

## CPU使用率与负载（Load）的区别
CPU利用率：显示的是程序在运行期间实时占用的CPU百分比.

CPU负载：显示的是一段时间内正在使用和等待使用CPU的平均任务数.

简单理解，一个是cpu的实时使用情况，一个是cpu的当前以及未来一段时间的使用情况.

## 查看系统负载

1. uptime命令

2. w命令

3. top命令

## 机器正常负载范围（单核）
经验法则是这样的: 
当系统负荷持续大于0.7，你必须开始调查了，问题出在哪里，防止情况恶化。

当系统负荷持续大于1.0，你必须动手寻找解决办法，把这个值降下来。

当系统负荷达到5.0，就表明你的系统有很严重的问题，长时间没有响应，或者接近死机了。你不应该让系统达到这个值。

## 负载比较高怎么办？
同内存使用率高的处理方法

## 常见场景
### 磁盘读写请求过多就会导致大量I/O等待
此时表现为`CPU使用率低而负载高`. cpu的工作效率要高于磁盘，而进程在cpu上面运行需要访问磁盘文件，这个时候cpu会向内核发起调用文件的请求，让内核去磁盘取文件，这个时候会切换到其他进程或者空闲，这个任务就会转换为不可中断睡眠状态。当这种读写请求过多就会导致不可中断睡眠状态的进程过多，从而导致负载高，cpu低的情况。

### MySQL中存在没有索引的语句或存在死锁.
MySQL的数据是存储在硬盘中，如果需进行sql查询，要先把数据从磁盘加载到内存中。当在数据特别大的时候，如果执行的sql语句没有索引，就会造成扫描表的行数过大导致I/O阻塞，或者是语句中存在死锁，也会造成I/O阻塞，从而导致不可中断睡眠进程过多，导致负载过大。

### 外接硬盘故障，常见有挂载了NFS，但是NFS Server故障.
假如系统挂载了外接硬盘，如NFS(网络文件系统)共享存储，经常会有大量的读写请求去访问NFS存储的文件，如果这个时候NFS Server故障，那么就会导致进程读写请求一直获取不到资源，从而进程一直是不可中断状态，造成负载很高。


# 内存使用率异常

## 内存概念
### 物理内存
物理内存指通过物理内存条而获得的内存空间，即随机存取存储器（random access memory，RAM），是与CPU直接交换数据的内部存储器，也叫主存（内存）。

### 虚拟内存
虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换（也就是说，当物理内存不足时，可能会借用磁盘空间来充当内存使用）。与没有使用虚拟内存技术的系统相比，使用这种技术的系统使得大型程序的编写变得更容易，对真正的物理内存（例如RAM）的使用也更有效率。

### Swap分区
Swap分区（即交换区）在系统的物理内存不够用的时候（没有了buffers和cache时），可以临时存放使用率不高的内存分页，把这一部分物理内存释放出来，以供当前运行的程序使用。那些被释放的空间可能来自一些很长时间没有什么操作的程序，这些被释放的空间被临时保存到Swap分区中，等到那些程序要运行时，再从Swap分区中恢复保存的数据到内存中。

### buffers和cache的区别
>A buffer is something that has yet to be “written” to disk.  
A cache is something that has been “read” from the disk and stored for later use.

buffer 的主要目的进行流量整理，把突发的「大数量小规模的I/O」整理成平稳的「小数量较大规模的 I/O」，以减少响应次数（比如从网上下电影，你不能下一点点数据就写一下硬盘，而是积攒一定量的数据以后一整块一起写，不然硬盘都要被你玩坏了）

cache 是为了弥补高速设备和低速设备的鸿沟而引入的中间层，最终起到**加快访问速度**的作用;

## 查看内存使用情况

free命令  
free -g 可以以GB为单位显示, 同理 -k, -m.

top命令的信息里也可以查看内存使用情况.

![avatar](/resource/机器指标异常排查2.png)

`行`
* Mem 是内存的使用情况；
* -/+ buffers/cache 是物理内存的缓存统计情况；
* Swap 是交换空间的使用情况；

`列（Mem行）`
* total: 表示物理内存总大小；
* used: 表示总计分配给缓存（包含buffers 与cache ）使用的数量，其中可能部分缓存并未实际使用；
* free: 表示未被分配的内存；
* shared: 共享内存，一般系统不会用到；
* buffers: 系统分配但未被使用的buffers数量；
* cached: 系统分配但未被使用的cache 数量；

`列（-/+ buffers/cache行）`
* Used: 表示实际使用的buffers 与cache 总量，也是实际使用的内存总量；
* Free: 未被使用的buffers 与cache 和未被分配的内存之和，这就是系统当前实际可用内存；

`数据间的关系`

>used（-/+ buffers/cache） = used（Mem） – cached（Mem） – buffers（Mem）  
free（-/+ buffers/cache） = free（Mem） + cached （Mem）+ buffers（Mem）

**used（mem）为系统已分配内存大小；  
free（-/+ buffers/cache）为系统实际可用内存大小；**

## 内存占用飙高怎么办?
### 内存溢出
内存溢出：指程序运行过程中无法申请到足够的内存而导致的一种错误。内存溢出通常发生于OLD段或Perm段垃圾回收后，仍然无内存空间容纳新的Java对象的情况。

#### 堆内存溢出（outOfMemoryError：java heap space）
在jvm规范中，堆中的内存是用来生成对象实例和数组的。

如果细分，堆内存还可以分为年轻代和年老代，年轻代包括一个eden区和两个survivor区。

当生成新对象时，内存的申请过程如下：
1. jvm先尝试在eden区分配新建对象所需的内存；
2. 如果内存大小足够，申请结束，否则下一步；
3. jvm启动youngGC，试图将eden区中不活跃的对象释放掉，释放后若Eden空间仍然不足以放入新对象，则试图将部分Eden中活跃对象放入Survivor区；
4. Survivor区被用来作为Eden及old的中间交换区域，当OLD区空间足够时，Survivor区的对象会被移到Old区，否则会被保留在Survivor区；
5.  当OLD区空间不够时，JVM会在OLD区进行full GC；
6. full GC后，若Survivor及OLD区仍然无法存放从Eden复制过来的部分对象，导致JVM无法在Eden区为新对象创建内存区域，则出现”out of memory错误”：
>outOfMemoryError：java heap space

#### 方法区内存溢出（outOfMemoryError：permgem space）
在jvm规范中，方法区主要存放的是类信息、常量、静态变量等。

所以如果程序加载的类过多，或者使用反射、cglib等这种动态代理生成类的技术，就可能导致该区发生内存溢出，一般该区发生内存溢出时的错误信息为：
>outOfMemoryError：permgem space

#### 线程栈溢出（java.lang.StackOverflowError）
线程栈时线程独有的一块内存结构，所以线程栈发生问题必定是某个线程运行时产生的错误。

一般线程栈溢出是由于递归太深或方法调用层级过多导致的。

发生栈溢出的错误信息为：
>java.lang.StackOverflowError

### 内存泄露
内存泄露是指程序中动态分配内存给一些临时对象，代码段运行结束后，这些对象已经没有被使用，但由于GC roots可达，没有被GC回收，始终占用内存。简单来说即被分配的对象无用但可达，这种问题一般是代码设计存在缺陷导致的。

Step1. 使用top命令，查看占用内存较高的进程ID.

Step2. 使用jmap查看内存情况，并分析是否存在内存泄露。

```sh
# 查看java 堆（heap）使用情况
jmap -heap [进程PID]

# 查看堆内存(histogram)中的对象数量及大小
jmap -histo [进程PID]

# 将内存使用的详细情况输出到文件
jmap -dump:format=b,file=heapDump [进程PID]
```

得到堆dump文件后，使用MAT（Memory Analyzer Tool）或者Zprofile进行对象分析。

如果有大量对象在持续被引用，并没有被释放掉，那就产生了内存泄露。排查创建该对象的代码，进行修改。

常见的代码内存泄露的原因有：
* 长生命周期的对象持有短生命周期对象的引用.
* 修改hashset中对象的参数值，且参数是计算哈希值的字段.
* 机器的连接数和关闭时间设置.

### 堆外内存使用不当
`什么是堆外内存`

和堆内内存相对应，堆外内存就是把内存对象分配在Java虚拟机的堆以外的内存，这些内存直接受操作系统管理（而不是虚拟机），这样做的结果就是能够在一定程度上减少垃圾回收对应用程序造成的影响。

`堆外内存的优点`
* 减少了垃圾回收 因为垃圾回收会暂停其他的工作；
* 加快了复制的速度 堆内在flush到远程时，会先复制到直接内存，然后再发送，而堆外内存相当于省略掉了复制这个步骤；

`堆外内存的缺点`

堆外内存的缺点就是内存难以控制，使用了堆外内存就间接失去了JVM管理内存的可行性，改由自己来管理，当发生内存溢出时排查起来非常困难；

`堆外内存使用场景`

NIO引入了一种基于通道与缓冲区的IO方式，他可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的java.nio.DirectByteBuffer对象作为这块堆外内存的引用进行操作。

`异常解决`

DirectMemory容量可通过-XX:MaxDirectMemorySize指定，如果不指定，则默认与JAVA堆的最大值（-Xmx指定）一样。


